// https://leetcode.cn/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/description/
class Solution {
    public int iceBreakingGame(int num, int target) {
        if (num == 1) {
            return 0;
        }
        // 两种方式
        // int ret = listRetrive(num, target);
        int ret = mathCal(num, target);
        return ret;
    }

    // 链表模拟
    int listRetrive(int num, int target) {
        List<Integer> list = new ArrayList();
        for (int i = 0; i < num; i++) {
            list.add(i);
        }
        // 上一轮删除的数字的index，初始设置0
        int preIndex = 0;
        while (list.size() != 1) {
            // 本轮要删除的位置，是上一轮删除的index位置向右移动target-1，可能过界，因此用mod计算准确位置
            int removeIndex = (preIndex + target - 1) % list.size();
            list.remove(removeIndex);
            preIndex = removeIndex;
        }
        return list.get(0);
    }

    // 数学推导公式 因为最终肯定是剩下1个index=0的元素(很重要)，那么思考
    // 如何从f(n-1, m) 变成f(n,m) 或者另一个理解方式如何从f(n,m)还原为f(n-1, m)
    // 在f(n-1 ,m )的位置，左边加入m个元素，就得到了令f(n,m)剩下的1个元素index=0
    // 因此： f(n, m ) = (m + f(n-1, m)) % n
    int mathCal(int num, int target) {
        if (num == 1) {
            return 0;
        }
        return (target + mathCal(num - 1, target)) % num;
    }

}

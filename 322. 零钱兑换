// https://leetcode.cn/problems/coin-change/

class Solution {
    List<Integer> part = new ArrayList();
    Integer result = Integer.MAX_VALUE;

    /**
     * 暴力法，递归探索各种可能。先排个序进行剪枝，到某个元素已经超过了amount就不需要继续。如果已经递归的part.size()>已经寻找到的最小次数，也不用继续递归
     */
    public int coinChange(int[] coins, int amount) {
        if (coins == null || coins.length == 0 || amount < 0) {
            return -1;
        }
        if (amount == 0) {
            return 0;
        }
        // 为了找到最少个数，尝试先加大的数，更容易快速在递归回溯中中止
        Integer[] integerArray = Arrays.stream(coins).boxed().toArray(Integer[]::new);

        Arrays.sort(integerArray, Collections.reverseOrder());
        backtrace(integerArray, amount, 0, 0);
        return result == Integer.MAX_VALUE ? -1 : result;
    }

    public void backtrace(Integer[] coins, int amount, int partSum, int index) {
        // 注意part.size可以作为剪枝条件
        if (index >= coins.length || part.size() >= result || partSum > amount) {
            return;
        }
        int val = coins[index];
        if (partSum + val == amount) {
            result = Math.min(part.size() + 1, result);
            return;
        }

        // 包含当前金额。 注意这个判断不能写到更上面
        part.add(val);
        backtrace(coins, amount, partSum + val, index);
        part.remove(part.size() - 1);

        // 不包含当前金额
        backtrace(coins, amount, partSum, index + 1);
    }
}


// 下面不是本人代码，参考学习用DP思想记录一下
class Solution {
  /**
     * dp[i]表示金额i最少需要的硬币数目
     * 那么对于dp[i]，从每个coin开始取，取了硬币coin，那么dp[i-coin]表示剩余金额的硬币数，这个是已经算出来的
     * 那么，每个coin循环一遍，找到硬币数最少的情况
     */
    public int coinChange(int[] coins, int amout){
        if(coins.length == 0){
            return -1;
        }
        //dp[i]表示金额i最少需要的硬币数
        int[] dp = new int[amout+1];
        dp[0] = 0;
        for(int i=1;i<=amout;i++){
            int min = Integer.MAX_VALUE;
            for (final int coin : coins) {
                if (i - coin >= 0 && dp[i - coin] < min) {
                    min = dp[i - coin] + 1;
                }
            }
            dp[i] = min;
        }
        return dp[amout]== Integer.MAX_VALUE ? -1 : dp[amout];
    }
}



// https://leetcode.cn/problems/merge-intervals

class Solution {
    /**
     * 先按找每个区间的开始数字，进行升序排序
     * 对于每个区间，如果后一个区间的开始数字>=前一个区间的结束数字，则可以合并
     * 循环直到不满足条件，那么前面的合并结果区间加入到返回值中。
     */
    public int[][] merge(int[][] intervals) {
        if (intervals == null || intervals.length < 2) {
            return intervals;
        }

        // 先按找每个区间的开始数字，进行升序排序
        Arrays.sort(intervals, new Comparator<int[]>() {
            public int compare(int[] interval1, int[] interval2) {
                return interval1[0] - interval2[0];
            }
        });

        List<List<Integer>> ret = new ArrayList();
        for (int i = 0; i < intervals.length;) {
            // 对于每个区间，如果后一个区间的开始数字>=前一个区间的结束数字，则可以合并
            int j = i + 1;
            while (j < intervals.length && intervals[j][0] <= intervals[i][1]) {
                // 注意这里有可能[1,4] [2,3]
                intervals[i][1] = Math.max(intervals[i][1], intervals[j][1]);
                j++;
            }
            // 循环直到不满足条件，那么前面的合并结果区间加入到返回值中。
            List<Integer> tmp = new ArrayList();
            tmp.add(intervals[i][0]);
            tmp.add(intervals[i][1]);
            ret.add(tmp);
            i = j;
        }

        int[][] retArray = new int[ret.size()][2];
        for (int i = 0; i < ret.size(); i++) {
            List<Integer> pair = ret.get(i);
            retArray[i][0] = pair.get(0);
            retArray[i][1] = pair.get(1);
        }
        return retArray;
    }
}
